1. 클래스와 객체
	클래스는 객체를 만들기 위한 설계도다.
	클래스는 속성(객체가 가지는 고유한 데이터)과 기능을 포함하고 있다.
	객체는 클래스를 이용해서 메모리에 생성된다.
	클래스에 정의된 모든 속성, 모든 기능은 객체 생성한 후에만 사용할 수 있다.
	생성된 객체의 모든 속성, 모든 기능에 접근하기 위해서는 그 개체를 참조하는
	참조변수를 활용해야 한다.


2. 참조변수
	클래스 타입의 변수다. (기본자료형 타입이 아니다.)
	생성된 객체의 참조값(주소값)을 저장하고 있다.
	보통은 new 연산자가 객체 생성 후 반환하는 참조값을 가지게 된다.
	참조변수, 속성명, 참조변수, 메소드명()과 같은 형식으로 객체의 속성, 기능을 사용한다.


3. 생성자가 실행되는 시점
	생성자는 객체를 생성하는 new 연산자 다음에 표시한다.
	(반드시 new 연산자와 같이 사용된다.)
	객체 생성 직후에 실행된다.


4. 생성자의 역할
	객체 생성 직후에 수행할 작업을 정의한다. 
	(객체 생성작업에 개발자의 의도를 포함시킨다.)
	 - 멤버변수의 초기화 작업
	 - resource(자원) 연결 작업
	 - 환경설정정보 로딩 작업


5. this
	생성된 모든 객체가 묵시적으로 가지고 있는 속성
	this에는 생성된 객체 자기 자신을 참조하는 참조값을 가지고 있다.
	this.속성명, this.메소드명() 의 형식으로 사용하면 그 객체의 속성, 기능을 참조한다.


6. 메소드 중복정의 (overloading)를 사용하는 이유
	하나의 클래스안에 매개변수를 달리하는 같은 이름의 메소드를 여러 개 정의하는 것
	(매개변수 개수, 매개변수 타입, 매개변수 타입별 순서)
	같은 이름의 메소드로 정의함으로써 기능 수행에 일관성을 가지게 된다.


7. 은닉화를 시키는 방법
	클래스에서는 속성(데이터)과 기능이 정의되어 있다.
	속성(데이터)의 무결성을 유지하기 위해서 데이터를 임의로 조작하는 것을 막아야 한다.
	접근제한자(private)를 사용해서 속성에 대한 외부 접근을 차단하고, 
	대신 그 속성을 조회/조작하는 별도의 기능을 제공한다.


8. 상속을 사용하는 이유
	코드의 중복을 줄일 수 있다.
	같은 타입(부류)로 만들 수 있다.
	(상속을 받는다는 것은 상속받은 부모클래스와 같은 타입이 되는 것이다.)



9. 클래스의 형변환이란?
	상속관계(구현관계)에 있는 클래스들 간에만 형변환이 가능하다.

	부모클래스 p = new 자식클래스();	// 자동 형변환
	


10. 클래스의 형변환이 이루어지는 예
	class Parent {}
	class Child extends Parent {}

	Parent p = new Child();		// 자동 형변환
	Child c = (Child) p;		// 강제 형변환


11. 메소드 재정의(overriding)를 사용하는 이유
	상속관계에 클래스에서 부모로부터 물려받은 메소드가 자신이 사용하기 적합하지 않을 때
	똑같은 이름으로 기능을 재정의 하는 것
	자식클래스들이 자신에게 특화된 기능을 구현할 때 같은 이름으로 구현하게 할 수 있다.
	(클래스는 달라도 사용법이 동일한 메소드를 가지게 된다.)


12. 부모 객체와 자식객체를 임의로 지정하고 super를 활요해서 그림으로 표현해보기

	